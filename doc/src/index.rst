.. cpp:namespace-push:: nt

.. |BaseTypeDoc| replace:: The type of the contained object
.. |TagTypeDoc| replace:: A tag to uniquely identify an instance of :cpp:class:`nt::new_type`
.. |DerivationClauseDoc| replace:: A (possibly empty) list of derivation tags as generated by :cpp:func:`nt::deriving`

.. only:: html

   .. contents:: Table of Contents
      :depth: 5

#############
Documentation
#############

The ``newtype`` library provides types and functions to facilitate the creation of strong type aliases.

Example Usage
#############

.. note::

   All examples shown in this section can be found in the directory :literal:`examples/src` within the source root.

:ref:`new-type-usage-basic` below demonstrates the basic usage of :cpp:class:`new_type`.
In it, :cpp:class:`new_type` is used to create thre new strong aliases :literal:`Width`, :literal:`Height`, and :literal:`Area` that all alias :literal:`unsigned int`.

.. literalinclude:: ../../examples/src/basic_usage.cpp
   :language: c++
   :linenos:
   :name: new-type-usage-basic 
   :caption: Basic usage of :cpp:class:`new_type`

However, using :cpp:class:`new_type` in this fashion seem quite cumbersome.
Starting from the bottom, :literal:`unsigned int` can normally be shifted on to any :cpp:class:`std::basic_ostream`, like :cpp:var:`std::cout` in this example.
Since printing values, among other things, is a common scenario, ``newtype`` provides facilities to support automatic derivation of supporting functions.

.. literalinclude:: ../../examples/src/basic_usage_with_show.cpp
   :emphasize-lines: 1,2,9
   :language: c++
   :linenos:
   :name: new-type-usage-basic-show
   :caption: Improved usability using the :cpp:var:`Show` derivation tag

:ref:`new-type-usage-basic-show` demonstrates how the function template :cpp:func:`deriving` can be used to enable automatic derivation of the stream output operator for :literal:`Area`.
Similarly, it is possible to derive the stream input operators of :literal:`Width` and :literal:`Height`, as shown in :ref:`new-type-usage-basic-read` below.

.. literalinclude:: ../../examples/src/basic_usage_with_read.cpp
   :emphasize-lines: 7,8,31,32,34
   :language: c++
   :linenos:
   :name: new-type-usage-basic-read
   :caption: Deriving input operations using the :cpp:var:`Read` derivation tag

API
###

This section of the documentation describes the public API of the *new_type*.
It provides detailed descriptions of the types and functions designed to be used by applications.
All declarations described in this section are found in the namespace :cpp:any:`nt`, unless noted otherwise.

Header :literal:`<newtype/new_type.hpp>`
========================================

This header contains the definitions of the class template :cpp:class:`new_type` as well as a set of associated namespace-level functions.

Class template :cpp:class:`new_type`
------------------------------------

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause = deriving()> \
               new_type

   The class template :cpp:class:`new_type` is designed to allow the creation of new types based on existing types.
   Similarly to the Haskell newtype, this class template creates a new type that is layout equivalent to the underlying type.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   **Member Type Aliases**

   .. cpp:type:: base_type = BaseType

   .. cpp:type:: tag_type = TagType

   .. cpp:type:: derivation_clause_type = decltype(DerivationClause)

   **Static Data Members**

   .. cpp:var:: derivation_clause_type constexpr static derivation_clause = DerivationClause

   **Constructors**

   .. cpp:function:: constexpr new_type()

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow default-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is default-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type const &)

      **noexcept specification:**: This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type &&)

      **noexcept specification:**: This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType &)

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-construtible.

      **enablement:** This constructor shall be defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType &&)

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-construtible.

      **enablement:** This constructor shall be defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   **Assignment Operators**

   .. cpp:function:: constexpr new_type & operator=(new_type const &)

      **noexcept specification:** This assignment operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

      **default definition:** This assignment operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-assignable.
      Otherwise, this assignment operator shall be explicitely deleted.

   .. cpp:function:: constexpr new_type & operator=(new_type &&)

      **noexcept specification:** This assignment operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-assignable.

      **default definition:** This assignment operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-assignable.
      Otherwise, this assignment operator shall be explicitely deleted.

   **Accessors**

   .. cpp:function:: constexpr BaseType decay() const

      **noexcept specification:** This member function shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

   .. cpp:function:: constexpr operator BaseType() const

      **noexcept specification:** This conversion operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

      **explicit specification:** This conversion operator shall be explicit unless this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`ImplicitConversion`.

   **Member Access Trough Pointer**

   .. cpp:function:: constexpr BaseType operator->() noexcept

      **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`

   .. cpp:function:: constexpr BaseType const * operator->() const noexcept

      **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`
   
   .. versionadded:: 1.0.0


:literal:`namespace`-level functions and function templates
-----------------------------------------------------------

The functions and functions templates described in this section provide additional functionality for the class template :cpp:class:`new_type` that is not part of the class itself.

Equality Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs,\
                                            new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality.

   **enablement:** This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`==`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs,\
                                            BaseType const & rhs)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality with an instance of :cpp:type:`BaseType`.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`==` and b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.


   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(BaseType const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check an instance of :cpp:type:`BaseType` for equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`==` and b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.


   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const &,\
                                            new_type<BaseType, TagType, DerivationClause> const &)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality.

   **enablement:** This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`!=`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const &,\
                                            BaseType const &)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality with an instance of :cpp:type:`BaseType`.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`!=` and b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator!=(BaseType const &,\
                                            new_type<BaseType, TagType, DerivationClause> const &)

   Check an instance of :cpp:type:`BaseType` for in-equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type::base_type` supports comparison using the operator :literal:`!=` and b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.

   .. versionadded:: 1.0.0

Relational Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const &, \
                                           new_type<BaseType, TagType, DerivationClause> const &)

   **noexcept specification:** This comparison operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow less-than-comparable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports comparison using the operator :literal:`<` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Relational`.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const &, \
                                           new_type<BaseType, TagType, DerivationClause> const &)

   **noexcept specification:** This comparison operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow greater-than-comparable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports comparison using the operator :literal:`>` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Relational`.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const &, \
                                            new_type<BaseType, TagType, DerivationClause> const &)

   **noexcept specification:** This comparison operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow less-than-or-equal-comparable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports comparison using the operator :literal:`<=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Relational`.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const &, \
                                            new_type<BaseType, TagType, DerivationClause> const &)

   **noexcept specification:** This comparison operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow greater-than-or-equal-comparable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports comparison using the operator :literal:`>=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Relational`.

   .. versionadded:: 1.0.0

Stream I/O Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_ostream<CharType, StreamTraits> & operator<<(std::basic_ostream<CharType, StreamTraits> &, \
                                                                          new_type<BaseType, TagType, DerivationClause> const &)

   **noexcept specification:** This output operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow output streamable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports being output to a stream using the operator :literal:`<<` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Show`.

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_istream<CharType, StreamTraits> & operator>>(std::basic_istream<CharType, StreamTraits> &, \
                                                                          new_type<BaseType, TagType, DerivationClause> &)

   **noexcept specification:** This input operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow input streamable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` supports being read from a stream using the operator :literal:`>>` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Read`.

   .. versionadded:: 1.0.0

Arithmetic Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow addable as well as nothrow copy-constructible.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is addable using the operator :literal:`+` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow add-assignable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is add-assignable using the operator :literal:`+=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow subtractable as well as nothrow copy-constructible.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is subtractable using the operator :literal:`-` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow subtract-assignable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is subtract-assignable using the operator :literal:`-=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow multipliable as well as nothrow copy-constructible.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is multipliable using the operator :literal:`*` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow multiply-assignable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is multiply-assignable using the operator :literal:`*=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow dividable as well as nothrow copy-constructible.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is dividable using the operator :literal:`/` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   **noexcept specification:** This operator shall be noexcept iff. :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is nothrow divide-assignable.

   **enablement:** This operator shall be available iff. a) :cpp:type:`new_type<BaseType, TagType, DerivationClause>::base_type` is divide-assignable using the operator :literal:`/=` and b) :cpp:type:`DerivationClause` includes :cpp:var:`Arithmetic`.

:cpp:class:`std::hash` Support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:namespace-pop::

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause> \
               std::hash<nt::new_type<BaseType, TagType, DerivationClause>>

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   .. cpp:function:: constexpr std::size operator()(nt::new_type<BaseType, TagType, DerivationClause> const &) const

      **enablement:** This operator shall be available iff. a) :cpp:type:`nt::new_type::base_type` is hashable and b) :cpp:var:`DerivationClause` contains :cpp:var:`nt::Hash`.

   .. versionadded:: 1.0.0

.. cpp:namespace-push:: nt

Header :literal:`<newtype/derivable.hpp>`
=========================================

This header defines the alias template :cpp:type:`derivable` as well as the set of standard derivation tags.

Class template :cpp:type:`derivable`
------------------------------------

.. cpp:class:: template<typename NameTag> \
               derivable

   .. versionadded:: 1.0.0

.. _sec-standard-derivation-tags:

Standard derivation tags
------------------------

.. cpp:var:: auto constexpr Arithmetic = derivable<class arithmetic_tag>{}

   This tag enables the derivation of the following arithmetic operators:
   
      * :cpp:func:`operator+(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator+=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr EqBase = derivable<class eq_base_tag>{}

   This tag enables the derivation of following "equality comparison with base type" operators:

      * :cpp:func:`operator==(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator==(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`
      * :cpp:func:`operator!=(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator!=(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`

   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr ImplicitConversion = derivable<class implicit_conversion_tag>{}

   This tag enables the derivation of the implicit "conversion to base type" operator.
   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Hash = derivable<class hash_tag>{}

   This tag enables the derivation of a specialization of :cpp:class:`std::hash`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Indirection = derivable<class indirection_tag>{}

   .. .. cpp:function:: constexpr BaseType operator->() noexcept

   ..    **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`

   .. .. cpp:function:: constexpr BaseType const * operator->() const noexcept

   This tag enables the derivation of the "member access through pointer" operator :cpp:func:`operator->() <constexpr BaseType new_type::operator->()()>` (both in :literal:`const` and non-:literal:`const` variants).

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Read = derivable<class read_tag>{}

   This tag enables the derivation of the "stream output" :cpp:func:`operator\<\<(std::basic_ostream &, new_type const &) <operator<<>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Relational = derivable<class relational_tag>{}

   This tag enables the derivation of the following relational operators:
   
      * :cpp:func:`operator\<(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator\<=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Show = derivable<class show_tag>{}

   This tag enables the derivation of the "stream input" :cpp:func:`operator>>(std::basic_istream &, new_type &) <operator>>>`

   .. versionadded:: 1.0.0

Header :literal:`<newtype/deriving.hpp>`
========================================

This header contains the definition of the function template :cpp:func:`deriving`.

Function template :cpp:func:`deriving`
--------------------------------------

.. cpp:function:: template<typename... DerivableTags> \
                  constexpr derivation_clause<DerivableTags...> deriving(derivable<DerivableTags>... features) noexcept
   
   This function can be used to create a new :cpp:class:`derivation_clause` for use in the definitions of instances of :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

   .. seealso:: :ref:`sec-standard-derivation-tags` for a list of standard derivation tags

Header :literal:`<newtype/derivation_clause.hpp>`
=================================================

This header contains the definition of the class template :cpp:class:`derivation_clause`

Class template :cpp:class:`derivation_clause`
---------------------------------------------

.. cpp:class:: template<typename... DerivableTags> \
               derivation_clause

   Derivation clauses are used by :cpp:class:`new_type` to allow users to specify a set of automatically derived support functions.

   .. versionadded:: 1.0.0

   **Constructors**

   .. cpp:function:: constexpr derivation_clause(derivable<DerivableTags>...) noexcept

   **Evaluation Functions**

   .. cpp:function:: template<typename DerivableTag> \
                     constexpr bool operator()(derivable<DerivableTag>) const noexcept
   
   .. cpp:function:: template<typename DerivableTag, typename... RemainingDerivableTags> \
                     constexpr bool operator()(derivable<DerivableTag>, derivable<RemainingDerivableTags>...) const noexcept

   **Equality Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator==(derivation_clause<OtherDerivableTags...> other) const noexcept

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator!=(derivation_clause<OtherDerivableTags...> other) const noexcept

   **Relational Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<(derivation_clause<OtherDerivableTags...> other) const noexcept
   
   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>(derivation_clause<OtherDerivableTags...> other) const noexcept
   
   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<=(derivation_clause<OtherDerivableTags...> other) const noexcept

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>=(derivation_clause<OtherDerivableTags...> other) const noexcept
