.. cpp:namespace-push:: nt

.. |BaseTypeDoc| replace:: The type of the contained object
.. |TagTypeDoc| replace:: A tag to uniquely identify an instance of :cpp:class:`nt::new_type`
.. |DerivationClauseDoc| replace:: A (possibly empty) list of derivation tags as generated by :cpp:func:`nt::deriving`

.. only:: html

   .. contents:: Table of Contents
      :depth: 5

#############
Documentation
#############

The ``newtype`` library provides types and functions to facilitate the creation of strong type aliases.

Example Usage
#############

.. note::

   All examples shown in this section can be found in the directory :literal:`examples/src` within the source root.

:ref:`new-type-usage-basic` below demonstrates the basic usage of :cpp:class:`new_type`.
In it, :cpp:class:`new_type` is used to create thre new strong aliases :literal:`Width`, :literal:`Height`, and :literal:`Area` that all alias :literal:`unsigned int`.

.. literalinclude:: ../../examples/src/basic_usage.cpp
   :language: c++
   :linenos:
   :name: new-type-usage-basic 
   :caption: Basic usage of :cpp:class:`new_type`

However, using :cpp:class:`new_type` in this fashion seem quite cumbersome.
Starting from the bottom, :literal:`unsigned int` can normally be shifted on to any :cpp:class:`std::basic_ostream`, like :cpp:var:`std::cout` in this example.
Since printing values, among other things, is a common scenario, ``newtype`` provides facilities to support automatic derivation of supporting functions.

.. literalinclude:: ../../examples/src/basic_usage_with_show.cpp
   :emphasize-lines: 1,2,9
   :language: c++
   :linenos:
   :name: new-type-usage-basic-show
   :caption: Improved usability using the :cpp:var:`Show` derivation tag

:ref:`new-type-usage-basic-show` demonstrates how the function template :cpp:func:`deriving` can be used to enable automatic derivation of the stream output operator for :literal:`Area`.
Similarly, it is possible to derive the stream input operators of :literal:`Width` and :literal:`Height`, as shown in :ref:`new-type-usage-basic-read` below.

.. literalinclude:: ../../examples/src/basic_usage_with_read.cpp
   :emphasize-lines: 7,8,31,32,34
   :language: c++
   :linenos:
   :name: new-type-usage-basic-read
   :caption: Deriving input operations using the :cpp:var:`Read` derivation tag

API
###

This section of the documentation describes the public API of the *new_type*.
It provides detailed descriptions of the types and functions designed to be used by applications.
All declarations described in this section are found in the namespace :cpp:any:`nt`, unless noted otherwise.

Header :literal:`<newtype/new_type.hpp>`
========================================

This header contains the definitions of the class template :cpp:class:`new_type` as well as a set of associated namespace-level functions.

Class template :cpp:class:`new_type`
------------------------------------

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause = deriving()> \
               new_type

   The class template :cpp:class:`new_type` is designed to allow the creation of new types based on existing types.
   Similarly to the Haskell newtype, this class template creates a new type that is layout equivalent to the underlying type.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   **Member Type Aliases**

   .. cpp:type:: base_type = BaseType

   .. cpp:type:: tag_type = TagType

   .. cpp:type:: derivation_clause_type = decltype(DerivationClause)

   **Static Data Members**

   .. cpp:var:: derivation_clause_type constexpr static derivation_clause = DerivationClause

   **Constructors**

   .. cpp:function:: constexpr new_type()

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow default-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is default-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type const &)

      **noexcept specification:**: This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type &&)

      **noexcept specification:**: This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-construtible.

      **default definition:** This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType &)

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-construtible.

      **enablement:** This constructor shall be defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType &&)

      **noexcept specification:** This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-construtible.

      **enablement:** This constructor shall be defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-construtible.
      Otherwise, this constructor shall be explicitely deleted.

   **Assignment Operators**

   .. cpp:function:: constexpr new_type & operator=(new_type const &)

      **noexcept specification:** This assignment operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

      **default definition:** This assignment operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is copy-assignable.
      Otherwise, this assignment operator shall be explicitely deleted.

   .. cpp:function:: constexpr new_type & operator=(new_type &&)

      **noexcept specification:** This assignment operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow move-assignable.

      **default definition:** This assignment operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is move-assignable.
      Otherwise, this assignment operator shall be explicitely deleted.

   **Accessors**

   .. cpp:function:: constexpr BaseType decay() const

      **noexcept specification:** This member function shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

   .. cpp:function:: constexpr operator BaseType() const

      **noexcept specification:** This conversion operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is nothrow copy-assignable.

      **explicit specification:** This conversion operator shall be explicit unless this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`ImplicitConversion`.

   **Member Access Trough Pointer**

   .. cpp:function:: constexpr BaseType operator->() noexcept

      **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`

   .. cpp:function:: constexpr BaseType const * operator->() const noexcept

      **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`
   
   .. versionadded:: 1.0.0


:literal:`namespace`-level functions and function templates
-----------------------------------------------------------

The functions and functions templates described in this section provide additional functionality for the class template :cpp:class:`new_type` that is not part of the class itself.

Equality Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using :literal:`==`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs, BaseType const & rhs)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality with an instance of :cpp:type:`BaseType`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff.
   
      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`==` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(BaseType const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check an instance of :cpp:type:`BaseType` for equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff.
   
      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`==` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of theobjects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using :literal:`!=`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const & lhs, BaseType const & rhs)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality with an instance of :cpp:type:`BaseType`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of the object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff.

      a) :cpp:type:`new_type::base_type` supports comparison using :literal:`!=` and
      b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(BaseType const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check an instance of :cpp:type:`BaseType` for in-equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff.
   
      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`!=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

Relational Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`<` (*less-than*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow less-than-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`<` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`>` (*greater-than*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow greater-than-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`>` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`<=` (*less-than-equal*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow less-than-equal-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`<=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`>=` (*greater-than-equal*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow greater-than-equal-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`>=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

Stream I/O Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_ostream<CharType, StreamTraits> & operator<<(std::basic_ostream<CharType, StreamTraits> & out, new_type<BaseType, TagType, DerivationClause> const & value)

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :tparam CharType: The stream character type
   :tparam StreamTraits: The traits of the output stream
   :param out: The output stream
   :param value: A :cpp:class:`new_type` value to write to the output stream
   :returns: A reference to the output stream
   :throws: Any exception thrown by the stream-output operator of the object contained by :literal:`value`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow output-streamable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports being written to an output stream using :literal:`<<` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Show`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_istream<CharType, StreamTraits> & operator>>(std::basic_istream<CharType, StreamTraits> & in, new_type<BaseType, TagType, DerivationClause> & value)

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :tparam CharType: The stream character type
   :tparam StreamTraits: The traits of the input stream
   :param in: The input stream
   :param value: A :cpp:class:`new_type` value to be read from the output stream
   :returns: A reference to the input stream
   :throws: Any exception thrown by the stream-input operator of the object contained by :literal:`value`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow input-streamable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports being read from an input stream using :literal:`>>` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Read`

   .. versionadded:: 1.0.0

Arithmetic Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Add two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the addition
   :param rhs: The right-hand side of the addition
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`+` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the addition operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow addable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports addition using :literal:`+` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Add two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the addition
   :param rhs: The right-hand side of the addition
   :returns: A reference to the first argument containing the value modified by applying :literal:`+=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the addition-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow add-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports addition using :literal:`+=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Subtract two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the subtraction
   :param rhs: The right-hand side of the subtraction
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`-` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the subtraction operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow subtractable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports subtraction using :literal:`-` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Subtract two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the subtraction
   :param rhs: The right-hand side of the subtraction
   :returns: A reference to the first argument containing the value modified by applying :literal:`-=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the subtraction-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow subtract-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports subtraction using :literal:`-=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Multiply two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the multiplication
   :param rhs: The right-hand side of the multiplication
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`*` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the multiplication operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow multipliable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports multiplication using :literal:`*` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Multiply two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the multiplication
   :param rhs: The right-hand side of the multiplication
   :returns: A reference to the first argument containing the value modified by applying :literal:`*=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the multiplication-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow multiply-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports multiplication using :literal:`*=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Divide two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the division
   :param rhs: The right-hand side of the division
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`/` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the division operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow dividable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports division using :literal:`/` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0
.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Divide two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the division
   :param rhs: The right-hand side of the division
   :returns: A reference to the first argument containing the value modified by applying :literal:`/=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the division-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.
            
            a. :cpp:type:`new_type::base_type` is *nothrow divide-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports division using :literal:`/=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

:cpp:class:`std::hash` Support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:namespace-pop::

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause> \
               std::hash<nt::new_type<BaseType, TagType, DerivationClause>>

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   .. cpp:function:: constexpr std::size operator()(nt::new_type<BaseType, TagType, DerivationClause> const & value) const

      :param value: A :cpp:class:`nt::new_type` value to be hashed
      :returns: The result of applying :cpp:class:`std::hash` to the object contained by :literal:`value`
      :throws: Any exception thrown by the call operator of the specialization of :cpp:class`std::hash` for the type of the object contained by :literal:`value`.
      :enablement: This operator shall be available iff.
      
         a. :cpp:type:`nt::new_type::base_type` is hashable and
         b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Hash <nt::Hash>`.

   .. versionadded:: 1.0.0

.. cpp:namespace-push:: nt

Header :literal:`<newtype/derivable.hpp>`
=========================================

This header defines the alias template :cpp:type:`derivable` as well as the set of standard derivation tags.

Class template :cpp:type:`derivable`
------------------------------------

.. cpp:class:: template<typename NameTag> \
               derivable

   :tparam NameTag: A tag uniquely identifing a specific derivation tag

   .. versionadded:: 1.0.0

.. _sec-standard-derivation-tags:

Standard derivation tags
------------------------

.. cpp:var:: auto constexpr Arithmetic = derivable<class arithmetic_tag>{}

   This tag enables the derivation of the following arithmetic operators:
   
      * :cpp:func:`operator+(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator+=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr EqBase = derivable<class eq_base_tag>{}

   This tag enables the derivation of following "equality comparison with base type" operators:

      * :cpp:func:`operator==(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator==(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`
      * :cpp:func:`operator!=(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator!=(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`

   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr ImplicitConversion = derivable<class implicit_conversion_tag>{}

   This tag enables the derivation of the implicit "conversion to base type" operator.
   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Hash = derivable<class hash_tag>{}

   This tag enables the derivation of a specialization of :cpp:class:`std::hash`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Indirection = derivable<class indirection_tag>{}

   .. .. cpp:function:: constexpr BaseType operator->() noexcept

   ..    **enablement:** This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation_clause` contains :cpp:var:`Indirection`

   .. .. cpp:function:: constexpr BaseType const * operator->() const noexcept

   This tag enables the derivation of the "member access through pointer" operator :cpp:func:`operator->() <constexpr BaseType new_type::operator->()()>` (both in :literal:`const` and non-:literal:`const` variants).

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Read = derivable<class read_tag>{}

   This tag enables the derivation of the "stream output" :cpp:func:`operator\<\<(std::basic_ostream &, new_type const &) <operator<<>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Relational = derivable<class relational_tag>{}

   This tag enables the derivation of the following relational operators:
   
      * :cpp:func:`operator\<(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator\<=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Show = derivable<class show_tag>{}

   This tag enables the derivation of the "stream input" :cpp:func:`operator>>(std::basic_istream &, new_type &) <operator>>>`

   .. versionadded:: 1.0.0

Header :literal:`<newtype/deriving.hpp>`
========================================

This header contains the definition of the function template :cpp:func:`deriving`.

Function template :cpp:func:`deriving`
--------------------------------------

.. cpp:function:: template<typename... DerivableTags> \
                  constexpr derivation_clause<DerivableTags...> deriving(derivable<DerivableTags>... features) noexcept
   
   This function can be used to create a new :cpp:class:`derivation_clause` for use in the definitions of instances of :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

   .. seealso:: :ref:`sec-standard-derivation-tags` for a list of standard derivation tags

Header :literal:`<newtype/derivation_clause.hpp>`
=================================================

This header contains the definition of the class template :cpp:class:`derivation_clause`

Class template :cpp:class:`derivation_clause`
---------------------------------------------

.. cpp:class:: template<typename... DerivableTags> \
               derivation_clause

   Derivation clauses are used by :cpp:class:`new_type` to allow users to specify a set of automatically derived support functions.

   .. versionadded:: 1.0.0

   **Constructors**

   .. cpp:function:: constexpr derivation_clause(derivable<DerivableTags>...) noexcept

   **Evaluation Functions**

   .. cpp:function:: template<typename DerivableTag> \
                     constexpr bool operator()(derivable<DerivableTag>) const noexcept
   
   .. cpp:function:: template<typename DerivableTag, typename... RemainingDerivableTags> \
                     constexpr bool operator()(derivable<DerivableTag>, derivable<RemainingDerivableTags>...) const noexcept

   **Equality Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator==(derivation_clause<OtherDerivableTags...> other) const noexcept

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator!=(derivation_clause<OtherDerivableTags...> other) const noexcept

   **Relational Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<(derivation_clause<OtherDerivableTags...> other) const noexcept
   
   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>(derivation_clause<OtherDerivableTags...> other) const noexcept
   
   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<=(derivation_clause<OtherDerivableTags...> other) const noexcept

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>=(derivation_clause<OtherDerivableTags...> other) const noexcept
