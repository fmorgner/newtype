.. cpp:namespace-push:: nt

.. |BaseTypeDoc| replace:: The type of the contained object
.. |TagTypeDoc| replace:: A tag to uniquely identify an instance of :cpp:class:`nt::new_type`
.. |DerivationClauseDoc| replace:: A (possibly empty) list of derivation tags as generated by :cpp:func:`nt::deriving`

.. only:: html

   .. contents:: Table of Contents
      :depth: 5

#############
Documentation
#############

The ``newtype`` library provides types and functions to facilitate the creation of strong type aliases.

Example Usage
#############

.. note::

   All examples shown in this section can be found in the directory :literal:`examples/src` within the source root.

:ref:`new-type-usage-basic` below illustrates the basic usage of :cpp:class:`new_type`.
In it, :cpp:class:`new_type` is used to create three new strong aliases :literal:`Width`, :literal:`Height`, and :literal:`Area`, all aliasing :literal:`unsigned int`.

.. literalinclude:: ../../examples/src/basic_usage.cpp
   :language: c++
   :linenos:
   :name: new-type-usage-basic
   :caption: Basic usage of :cpp:class:`new_type`

However, using :cpp:class:`new_type` in this fashion is quite cumbersome.
Starting from the bottom, :literal:`unsigned int` can normally be shifted on to any :cpp:class:`std::basic_ostream`, like :cpp:var:`std::cout` in this example.
Since printing values, among others, is a common use case, ``newtype`` provides facilities to support automatic derivation of supporting functions.

.. literalinclude:: ../../examples/src/basic_usage_with_show.cpp
   :emphasize-lines: 7,38
   :language: c++
   :linenos:
   :name: new-type-usage-basic-show
   :caption: Improved usability using the :cpp:var:`Show` derivation tag

:ref:`new-type-usage-basic-show` illustrates how the function template :cpp:func:`deriving` can be used to enable automatic derivation of the stream output operator for :literal:`Area`.
Similarly, it is possible to derive the stream input operators of :literal:`Width` and :literal:`Height`, as shown in :ref:`new-type-usage-basic-read` below.

.. literalinclude:: ../../examples/src/basic_usage_with_read.cpp
   :emphasize-lines: 5,6,29,30,32
   :language: c++
   :linenos:
   :name: new-type-usage-basic-read
   :caption: Deriving input operations using the :cpp:var:`Read` derivation tag

API
###

This section of the documentation describes the public API of the *new_type*.
It provides detailed descriptions of the types and functions designed to be used by applications.
All declarations described in this section are found in the namespace :cpp:any:`nt`, unless noted otherwise.

Header :literal:`<newtype/new_type.hpp>`
========================================

This header contains the definitions of the class template :cpp:class:`new_type` as well as a set of associated namespace-level functions.

Class template :cpp:class:`new_type`
------------------------------------

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause = deriving()> \
               new_type

   The class template :cpp:class:`new_type` is designed to allow the creation of new types based on existing types.
   Similarly to the newtype keyword in Haskell, this class template creates a new type that is layout equivalent to the underlying type.
   During creation of the of new strong type, features can be derived using :cpp:any:`nt::deriving`.
   Actual feature availability depends on the :cpp:any:`BaseType` chosen for :cpp:class:`new_type` instance.
   For example, deriving :cpp:any:`nt::Show` for a :cpp:class:`new_type` instance over a type not supporting output on a standard output stream, will not cause the instance to be output-streamable.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   .. versionadded:: 1.0.0

   **Member Type Aliases**

   .. cpp:type:: base_type = BaseType

   .. cpp:type:: tag_type = TagType

   .. cpp:type:: derivation_clause_type = decltype(DerivationClause)

   .. cpp:type:: iterator = typename BaseType::iterator

      :enablement: This type alias is defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` has a member type :cpp:type:`iterator <new_type::base_type::iterator>` and the :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable`.

      .. versionadded:: 1.1.0

   .. cpp:type:: const_iterator = typename BaseType::const_iterator

      :enablement: This type alias is defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` has a member type :cpp:type:`const_iterator <new_type::base_type::const_iterator>` and the :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable`.

      .. versionadded:: 1.1.0

   .. cpp:type:: reverse_iterator = typename BaseType::reverse_iterator

      :enablement: This type alias is defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` has a member type :cpp:type:`reverse_iterator <new_type::base_type::reverse_iterator>` and the :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable`.

      .. versionadded:: 1.1.0

   .. cpp:type:: const_reverse_iterator = typename BaseType::const_reverse_iterator

      :enablement: This type alias is defined iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` has a member type :cpp:type:`const_reverse_iterator <new_type::base_type::const_reverse_iterator>` and the :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable`.

      .. versionadded:: 1.1.0

   **Static Data Members**

   .. cpp:var:: static derivation_clause_type constexpr derivation_clause = DerivationClause

   **Constructors**

   .. cpp:function:: constexpr new_type() noexcept(std::is_nothrow_default_constructible_v<base_type>)

      Construct a new instance of this :cpp:class:`new_type` by default constructing the contained object.

      :throws: Any exception thrown by the default constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This constructor is noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow default-construtible*.
      :enablement: This constructor is defined as :cpp:expr:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *default-construtible*.
                   Otherwise, this constructor is declared as explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type const & other) noexcept(std::is_nothrow_copy_constructible_v<base_type>)

      Construct a new instance of this :cpp:class:`new_type` by copy-constructing the contained object using the value contained by :cpp:any:`other`.

      :param other: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the copy-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow copy-construtible*.
      :enablement: This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *copy-construtible*.
                   Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(new_type && other)

      Construct a new instance of this :cpp:class:`new_type` by move-constructing the contained object using the value contained by :literal:`other`.

      :param other: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the move-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow move-construtible*.
      :enablement: This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *move-construtible*.
                   Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType const & value)

      Construct a new instance of this :cpp:class:`new_type` by copy-constructing the contained object using :literal:`value`.

      :param value: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the copy-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow copy-construtible*.
      :enablement: This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *copy-construtible*.
                   Otherwise, this constructor shall be explicitely deleted.

   .. cpp:function:: constexpr new_type(BaseType && value)

      Construct a new instance of this :cpp:class:`new_type` by move-constructing the contained object using :literal:`value`.

      :param value: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the move-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This constructor shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow move-construtible*.
      :enablement: This constructor shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *move-construtible*.
                   Otherwise, this constructor shall be explicitely deleted.

   **Assignment Operators**

   .. cpp:function:: constexpr new_type & operator=(new_type const & other)

      Copy the value of an existing instance of this :cpp:class:`new_type` and replace this instance's value

      :param other: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the copy-assignment operator of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow copy-assignable*.
      :enablement: This operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *copy-assignable*.
                   Otherwise, this operator shall be explicitely deleted.

   .. cpp:function:: constexpr new_type & operator=(new_type && other)

      Move the value of an existing instance of this :cpp:class:`new_type` and replace this instance's value

      :param other: An existing instance of this :cpp:class:`new_type`
      :throws: Any exception thrown by the move-assignment operator of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow move-assignable*.
      :enablement: This operator shall be defined as :literal:`= default` iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *move-assignable*.
                   Otherwise, this operator shall be explicitely deleted.

   **Accessors**

   .. cpp:function:: constexpr BaseType decay() const

      Retrieve a copy of the object contained by this :cpp:class:`new_type` object

      :throws: Any exception thrown by the copy-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow copy-constructible*.

   .. cpp:function:: constexpr operator BaseType() const

      Retrieve a copy of the object contained by this :cpp:class:`new_type` object

      :throws: Any exception thrown by the copy-constructor of this :cpp:class:`new_type`'s :cpp:type:`base_type`.
               This operator shall be noexcept iff. this :cpp:class:`new_type`'s :cpp:type:`base_type` is *nothrow copy-constructible*.
      :explicit: This conversion operator shall be explicit unless this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`ImplicitConversion`.

   **Member Access Through Pointer**

   .. cpp:function:: constexpr BaseType operator->() noexcept

      Perform "member access through pointer" via a pointer to object contained by this :cpp:class:`new_type`

      :enablement: This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Indirection`

   .. cpp:function:: constexpr BaseType const * operator->() const noexcept

      Perform "member access through pointer" via a pointer to object contained by this :cpp:class:`new_type`

      :enablement: This operator shall be available iff. this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Indirection`

   **Iterators**

   .. cpp:function:: constexpr iterator begin()

      Get an iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`begin() <new_type::base_type::begin()>` that returns an instance of type :cpp:type:`iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator begin() const

      Get a constant iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`begin() const <new_type::base_type::begin()>` that returns an instance of type :cpp:type:`const_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator cbegin() const

      Get a constant iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`cbegin() const <new_type::base_type::cbegin()>` that returns an instance of type :cpp:type:`const_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator rbegin()

      Get a reverse iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`rbegin() <new_type::base_type::rbegin()>` that returns an instance of type :cpp:type:`reverse_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator rbegin() const

      Get a constant reverse iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`rbegin() const <new_type::base_type::rbegin()>` that returns an instance of type :cpp:type:`const_reverse_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator crbegin() const

      Get a constant reverse iterator to the beginning of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`crbegin() const <new_type::base_type::crbegin()>` that returns an instance of type :cpp:type:`const_reverse_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator end()

      Get an iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`end() <new_type::base_type::end()>` that returns an instance of type :cpp:type:`iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator end() const

      Get a constant iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`end() const <new_type::base_type::end()>` that returns an instance of type :cpp:type:`const_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator cend() const

      Get a constant iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`cend() const <new_type::base_type::cend()>` that returns an instance of type :cpp:type:`const_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator rend()

      Get a reverse iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`rend() <new_type::base_type::rend()>` that returns an instance of type :cpp:type:`reverse_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator rend() const

      Get a constant reverse iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`rend() const <new_type::base_type::rend()>` that returns an instance of type :cpp:type:`const_reverse_iterator`

      .. versionadded:: 1.1.0

   .. cpp:function:: constexpr iterator crend() const

      Get a constant reverse iterator beyond the end of the object contained by this :cpp:class:`new_type`

      :enablement: This function shall be available iff.

         a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <derivation_clause>` contains :cpp:var:`Iterable` and
         b) this :cpp:class:`new_type`'s :cpp:type:`base type <base_type>` has a non-static member function :cpp:func:`crend() const <new_type::base_type::crend()>` that returns an instance of type :cpp:type:`const_reverse_iterator`

      .. versionadded:: 1.1.0

:literal:`namespace`-level functions and function templates
-----------------------------------------------------------

The functions and functions templates described in this section provide additional functionality for the class template :cpp:class:`new_type` that is not part of the class itself.

Equality Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using :literal:`==`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(new_type<BaseType, TagType, DerivationClause> const & lhs, BaseType const & rhs)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for equality with an instance of :cpp:type:`BaseType`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`==` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator==(BaseType const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check an instance of :cpp:type:`BaseType` for equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow equals-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`==` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check two instances of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of theobjects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff. :cpp:type:`new_type::base_type` supports comparison using :literal:`!=`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(new_type<BaseType, TagType, DerivationClause> const & lhs, BaseType const & rhs)

   Check an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` for in-equality with an instance of :cpp:type:`BaseType`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
   :throws: Any exception thrown by the comparison of the object contained by :literal:`lhs` with an object of the :cpp:type:`base type <new_type::base_type>`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff.

      a) :cpp:type:`new_type::base_type` supports comparison using :literal:`!=` and
      b) the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator!=(BaseType const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Check an instance of :cpp:type:`BaseType` for in-equality with an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`.
   :throws: Any exception thrown by the comparison of an object of :cpp:type:`base type <new_type::base_type>` with the object contained by :literal:`rhs`. This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow not-equals-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`!=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`EqBase`

   .. versionadded:: 1.0.0

Relational Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`<` (*less-than*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow less-than-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`<` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`>` (*greater-than*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow greater-than-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`>` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`<=` (*less-than-equal*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow less-than-equal-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`<=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Compare two instances of the same :cpp:class:`new_type` using :literal:`>=` (*greater-than-equal*).

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the comparison
   :param rhs: The right-hand side of the comparison
   :returns: The value returned by the comparison of the contained objects.
   :throws: Any exception thrown by the comparison operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow greater-than-equal-comparable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports comparison using :literal:`>=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Relational`

   .. versionadded:: 1.0.0

Stream I/O Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_ostream<CharType, StreamTraits> & operator<<(std::basic_ostream<CharType, StreamTraits> & out, new_type<BaseType, TagType, DerivationClause> const & value)

   Write an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` to a standard :cpp:type:`ostream <std::ostream>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :tparam CharType: The stream character type
   :tparam StreamTraits: The traits of the output stream
   :param out: The output stream
   :param value: A :cpp:class:`new_type` value to write to the output stream
   :returns: A reference to the output stream
   :throws: Any exception thrown by the stream-output operator of the object contained by :literal:`value`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow output-streamable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports being written to an output stream using :literal:`<<` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Show`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, \
                  typename TagType, \
                  auto DerivationClause, \
                  typename CharType, \
                  typename StreamTraits> \
                  std::basic_istream<CharType, StreamTraits> & operator>>(std::basic_istream<CharType, StreamTraits> & in, new_type<BaseType, TagType, DerivationClause> & value)

   Read an instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` from a standard :cpp:type:`istream <std::istream>`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :tparam CharType: The stream character type
   :tparam StreamTraits: The traits of the input stream
   :param in: The input stream
   :param value: A :cpp:class:`new_type` value to be read from the output stream
   :returns: A reference to the input stream
   :throws: Any exception thrown by the stream-input operator of the object contained by :literal:`value`.
            This operator shall be noexcept iff. :cpp:type:`new_type::base_type` is *nothrow input-streamable*.
   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports being read from an input stream using :literal:`>>` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Read`

   .. versionadded:: 1.0.0

Arithmetic Operators
~~~~~~~~~~~~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Add two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the addition
   :param rhs: The right-hand side of the addition
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`+` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the addition operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow addable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports addition using :literal:`+` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Add two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the addition
   :param rhs: The right-hand side of the addition
   :returns: A reference to the first argument containing the value modified by applying :literal:`+=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the addition-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow add-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports addition using :literal:`+=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Subtract two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the subtraction
   :param rhs: The right-hand side of the subtraction
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`-` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the subtraction operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow subtractable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports subtraction using :literal:`-` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Subtract two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the subtraction
   :param rhs: The right-hand side of the subtraction
   :returns: A reference to the first argument containing the value modified by applying :literal:`-=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the subtraction-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow subtract-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports subtraction using :literal:`-=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Multiply two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the multiplication
   :param rhs: The right-hand side of the multiplication
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`*` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the multiplication operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow multipliable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports multiplication using :literal:`*` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Multiply two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the multiplication
   :param rhs: The right-hand side of the multiplication
   :returns: A reference to the first argument containing the value modified by applying :literal:`*=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the multiplication-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow multiply-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports multiplication using :literal:`*=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Divide two instances of the same :cpp:class:`new_type`.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the division
   :param rhs: The right-hand side of the division
   :returns: A new instance of :cpp:class:`new_type\<BaseType, TagType, DerivationClause>` containing the result of applying :literal:`/` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the division operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow dividable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports division using :literal:`/` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0
.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)

   Divide two instances of the same :cpp:class:`new_type` by overwriting the first one.

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param lhs: The left-hand side of the division
   :param rhs: The right-hand side of the division
   :returns: A reference to the first argument containing the value modified by applying :literal:`/=` to the objects contained by :literal:`lhs` and :literal:`rhs`.
   :throws: Any exception thrown by the division-assignment operator of the objects contained by :literal:`lhs` and :literal:`rhs`.
            This operator shall be noexcept iff.

            a. :cpp:type:`new_type::base_type` is *nothrow divide-assignable* and
            b. :cpp:type:`new_type::base_type` is *nothrow copy-constructible*

   :enablement: This operator shall be available iff.

      a. :cpp:type:`new_type::base_type` supports division using :literal:`/=` and
      b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Arithmetic`

   .. versionadded:: 1.0.0

Iterators
~~~~~~~~~

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::iterator begin(new_type<BaseType, TagType, DerivationClause> & obj)

   Get an iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :literal:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`begin(BaseType &)` that returns an instance of type :cpp:type:`new_type::iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_iterator begin(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`begin(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_iterator cbegin(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`cbegin(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::reverse_iterator rbegin(new_type<BaseType, TagType, DerivationClause> & obj)

   Get a reverse iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :literal:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`rbegin(BaseType &)` that returns an instance of type :cpp:type:`new_type::reverse_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_reverse_iterator rbegin(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant reverse iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`rbegin(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_reverse_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_reverse_iterator crbegin(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant reverse iterator to the beginning of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator to the begining of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`crbegin(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_reverse_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::iterator end(new_type<BaseType, TagType, DerivationClause> & obj)

   Get an iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :literal:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`end(BaseType &)` that returns an instance of type :cpp:type:`new_type::iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_iterator end(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`end(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_iterator cend(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`cend(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::reverse_iterator rend(new_type<BaseType, TagType, DerivationClause> & obj)

   Get a reverse iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :literal:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`rend(BaseType &)` that returns an instance of type :cpp:type:`new_type::reverse_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_reverse_iterator rend(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant reverse iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`rend(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_reverse_iterator`

   .. versionadded:: 1.1.0

.. cpp:function:: template<typename BaseType, typename TagType, auto DerivationClause> \
                  constexpr new_type<BaseType, TagType, DerivationClause>::const_reverse_iterator crend(new_type<BaseType, TagType, DerivationClause> const & obj)

   Get a constant reverse iterator beyond the end of the object contained by an instance of :cpp:class:`new_type`

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|
   :param obj: The object to retrieve the iterator from
   :returns: An iterator beyond the end of the object of contained by :cpp:var:`obj`.
   :throws: Any exception
   :enablement: This function shall be available iff.

      a) this :cpp:class:`new_type`'s :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Iterable` and
      b) for the :cpp:class:`new_type`'s :cpp:type:`base type <BaseType>` exists a namespace-level function :literal:`crend(BaseType const &)` that returns an instance of type :cpp:type:`new_type::const_reverse_iterator`

   .. versionadded:: 1.1.0

:cpp:class:`std::hash` Support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. cpp:namespace-pop::

.. cpp:class:: template<typename BaseType, typename TagType, auto DerivationClause> \
               std::hash<nt::new_type<BaseType, TagType, DerivationClause>>

   :tparam BaseType: |BaseTypeDoc|
   :tparam TagType: |TagTypeDoc|
   :tparam DerivationClause: |DerivationClauseDoc|

   Hash an instance of :cpp:class:`new_type` using the hash implementation of the :cpp:type:`base type <BaseType>`.

   .. cpp:function:: constexpr std::size operator()(nt::new_type<BaseType, TagType, DerivationClause> const & value) const

      :param value: A :cpp:class:`nt::new_type` value to be hashed
      :returns: The result of applying :cpp:class:`std::hash` to the object contained by :literal:`value`
      :throws: Any exception thrown by the call operator of the specialization of :cpp:class`std::hash` for the type of the object contained by :literal:`value`.
      :enablement: This operator shall be available iff.

         a. :cpp:type:`nt::new_type::base_type` is hashable and
         b. the :cpp:var:`derivation clause <DerivationClause>` contains :cpp:var:`Hash <nt::Hash>`.

   .. versionadded:: 1.0.0

.. cpp:namespace-push:: nt

Header :literal:`<newtype/derivable.hpp>`
=========================================

This header defines the alias template :cpp:type:`derivable` as well as the set of standard derivation tags.

Class template :cpp:type:`derivable`
------------------------------------

.. cpp:class:: template<typename NameTag> \
               derivable

   :tparam NameTag: A tag uniquely identifing a specific derivation tag

   .. versionadded:: 1.0.0

.. _sec-standard-derivation-tags:

Standard derivation tags
------------------------

.. cpp:var:: auto constexpr Arithmetic = derivable<class arithmetic_tag>{}

   This tag enables the derivation of the following arithmetic operators:

      * :cpp:func:`operator+(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator+(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator-(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator*(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> operator/(new_type<BaseType, TagType, DerivationClause> const & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator+=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator+=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator-=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator-=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator*=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator*=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`
      * :cpp:func:`operator/=(new_type &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr new_type<BaseType, TagType, DerivationClause> & operator/=(new_type<BaseType, TagType, DerivationClause> & lhs, new_type<BaseType, TagType, DerivationClause> const & rhs)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr EqBase = derivable<class eq_base_tag>{}

   This tag enables the derivation of following "equality comparison with base type" operators:

      * :cpp:func:`operator==(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator==(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator==(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`
      * :cpp:func:`operator!=(BaseType const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(BaseType const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator!=(new_type const &, BaseType const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool nt::operator!=(new_type<BaseType, TagType, DerivationClause> const &, BaseType const &)>`

   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr ImplicitConversion = derivable<class implicit_conversion_tag>{}

   This tag enables the derivation of the implicit "conversion to base type" operator.
   By virtue of its nature, deriving this feature compromises the strength of the given :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Hash = derivable<class hash_tag>{}

   This tag enables the derivation of a specialization of :cpp:class:`std::hash`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Indirection = derivable<class indirection_tag>{}

   This tag enables the derivation of the "member access through pointer" operator :cpp:func:`operator->() <constexpr BaseType new_type::operator->()()>` (both in :literal:`const` and non-:literal:`const` variants).

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Iterable = derivable<class iterable_tag>{}

   This tag enables the derivation of the following "standard iterator functions":

      * :cpp:func:`begin() <constexpr typename BaseType::iterator new_type::begin()>`
      * :cpp:func:`begin() const <constexpr typename BaseType::iterator new_type::begin() const>`

   .. versionadded:: 1.1.0

.. cpp:var:: auto constexpr Read = derivable<class read_tag>{}

   This tag enables the derivation of the "stream output" :cpp:func:`operator\<\<(std::basic_ostream &, new_type const &) <operator<<>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Relational = derivable<class relational_tag>{}

   This tag enables the derivation of the following relational operators:

      * :cpp:func:`operator\<(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator\<=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator<=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`
      * :cpp:func:`operator>=(new_type const &, new_type const &) <template\<typename BaseType, typename TagType, auto DerivationClause> constexpr bool operator>=(new_type<BaseType, TagType, DerivationClause> const &, new_type<BaseType, TagType, DerivationClause> const &)>`

   .. versionadded:: 1.0.0

.. cpp:var:: auto constexpr Show = derivable<class show_tag>{}

   This tag enables the derivation of the "stream input" :cpp:func:`operator>>(std::basic_istream &, new_type &) <operator>>>`

   .. versionadded:: 1.0.0

Header :literal:`<newtype/deriving.hpp>`
========================================

This header contains the definition of the function template :cpp:func:`deriving`.

Function template :cpp:func:`deriving`
--------------------------------------

.. cpp:function:: template<typename... DerivableTags> \
                  constexpr derivation_clause<DerivableTags...> deriving(derivable<DerivableTags>... features) noexcept

   This function can be used to create a new :cpp:class:`derivation_clause` for use in the definitions of instances of :cpp:class:`new_type`.

   .. versionadded:: 1.0.0

   .. seealso:: :ref:`sec-standard-derivation-tags` for a list of standard derivation tags

Header :literal:`<newtype/derivation_clause.hpp>`
=================================================

This header contains the definition of the class template :cpp:class:`derivation_clause`

Class template :cpp:class:`derivation_clause`
---------------------------------------------

.. cpp:class:: template<typename... DerivableTags> \
               derivation_clause

   Derivation clauses are used by :cpp:class:`new_type` to allow users to specify a set of automatically derived support functions.

   :tparam DerivableTags: A (potentially empty) list of tag types identifying the contained derivations

   .. versionadded:: 1.0.0

   **Constructors**

   .. cpp:function:: constexpr derivation_clause(derivable<DerivableTags>...) noexcept

      Construct a new derivations clause containing the given derivations

   **Evaluation Functions**

   .. cpp:function:: template<typename DerivableTag> \
                     constexpr bool operator()(derivable<DerivableTag>) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` contains the given derivation

      :tparam DerivableTag: A tag uniquely identifying a derivation

   .. cpp:function:: template<typename DerivableTag, typename... RemainingDerivableTags> \
                     constexpr bool operator()(derivable<DerivableTag>, derivable<RemainingDerivableTags>...) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` contains **all** of the given derivations

      :tparam DerivableTag: A tag uniquely identifying a derivation
      :tparam RemainingDerivableTags: A list of tags uniquely identifying a list of derivations

   **Equality Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator==(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is identical to the one represented by :cpp:any:`other`.
      Two derivation clauses are considered equal iff. both contain the same derivations irrespective of their order.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator!=(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is different from the one represented by :cpp:any:`other`.
      Two derivation clauses are considered different iff. one contains at least one derivation not contained by the other.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`

   **Relational Comparison Operators**

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is a subset of the one represented by :cpp:any:`other`.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be a subset of another iff. the list of derivations of this instance forms a proper subset of the list of derivations of the other.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is a superset of the one represented by :cpp:any:`other`.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be a superset of another iff. the list of derivations of this instance forms a proper superset of the list of derivations of the other.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator<=(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is either identical to or a subset of the one represented by :cpp:any:`other`.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be identical to another iff. the list of derivations of this instance is identical to the list of derivations of the other.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be a subset of another iff. the list of derivations of this instance forms a proper subset of the list of derivations of the other.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`

   .. cpp:function:: template<typename... OtherDerivableTags> \
       constexpr bool operator>=(derivation_clause<OtherDerivableTags...> other) const noexcept

      Check if this :cpp:class:`derivation clause <derivation_clause>` is either identical to or a superset of the one represented by :cpp:any:`other`.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be identical to another iff. the list of derivations of this instance is identical to the list of derivations of the other.
      One :cpp:class:`derivation clause <derivation_clause>` is considered to be a superset of another iff. the list of derivations of this instance forms a proper superset of the list of derivations of the other.

      :tparam OtherDerivableTags: A (potentialy empty) list of tags uniquely identifying a list of derivations
      :param other: An existing :cpp:class:`derivation clause <derivation_clause>`
